a. 作者花了两页的篇幅讲述如何设计一套跨越模块边界异步收集数据的API，如何利用无锁缓冲区来提升性能，如何利用时间戳协助批处理。但是在implementation中，这些设计原则基本都没有实现。作者在仅有的334行实现代码里写了5个TODO，无锁缓冲区实际上存在并发问题，很多API的实现只是在日志里打印信息。而且在evaluation阶段完全没有针对这部分的实验。



b. 在内核使用GPU会引入内核空间任务与用户空间程序对GPU使用的竞争。作者认为目前尚未有明确的机制管理这种竞争。在design中，作者说可以在LAKE框架中通过eBPF定制竞争管理策略。但是在implement中，通过eBPF定制竞争策略并没有实现。在evaluation中，作者做了一个关于竞争的实验。这个实验中，竞争管理策略是“硬编码”的。当使用GPU的进程大于1个且GPU负载高于70%时，内核任务主动放弃GPU。这个实验似乎对一个“超参数”非常敏感，我试了不同的参数，得到的结果差异比较大。感觉这个实验是作者试了很多组合最后cherry pick了一个。



c. 作者在一些地方的描述有些“欺骗性”。除了LinnOS，其他的模块的ML替代方案并没有收集真实的系统运行数据，所有的数据都是固定的，作者做的实际是”在内核中使用Kleio/MLLB/KNN/KML的模型做推理“，而不是”从数据收集到推理到行动“的完整流程(我感觉有点工作量欺骗)。此外，作者用sync.标签表示这次测量包括**同步数据传输**的时间，没有这个标签表示**不包括同步传输时间**，结合前面的异步数据API，给人一种没有sync.标签表示**使用异步数据传输**的感觉。但实际上没有sync.标签表示**不考虑任何数据传输时间，仅考虑计算时间**



问题在于，我现在对这篇论文有比较多的成见。

我感觉文章提出的问题很有价值，实现了的那部分design有点ordinary, 没完全实现的那部分design没讲清楚，最后的evaluation有些欺骗性。



​         a我想表达的是，这部分design我没有看懂，于是去找源码想看看实现。但是作者这部分并没有给一个符合设计的实现，甚至可以说没有实现（只写了一点代码且存在bug，且完全没有在evalution中测试）。如果我要讲解这部分的内容，就会变成英语阅读理解，原文说了什么，我翻译后总结念一遍。
​        前面一部分有完整实现和测试的design其实我感觉思路上很简单：内核没有GPU的API，就在用户空间搭建一个proxy。数据传输开销大，就开一块专用共享内存。使用GPU可能会引入竞争，就在产生竞争的时候把GPU让给用户程序。
​	我感觉这篇文章的价值更多的是在实践上验证了这些思路的可能性。按照我的思路，我可能会把这篇文章讲得很平庸

​	